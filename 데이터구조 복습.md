<문자열>

객체 안에 있는 함수가 메서드

타이틀 형식은 pascal case 떠올리면 됨

데이터 검증시 isdigit isnumeric 정도는 쓸수도

메소드를 알고있는지보다 그런게 있었다고 떠올릴 수 있는 능력(구글링 하면됨)

strip은 문자열 지정하지 않으면 공백을 제거('', '\t', 공백, '\n' 이렇게 제거해줌)



<리스트>

join은 앞에있는게 뒤에있는것 각각 사이로 들어가는것

remove로 지웠을땐 지운곳이 공백이 되는것은 아님



#### 과목평가시에 append , insert, extend 의 차이를 물어볼 것!!

['a', 'b']

있을때

append는 ['a','b'] 그대로 들어감,   extend는 'a', 'b' 따로 들어감



**.sort(key)     ----> 원본변경         어떠한 key로 정렬할 것인가(lambda가 자주 사용됨)**

print(my_list.sort()) --------->이렇게하면 None!!!!(시험 가능)

![image-20220125095854077](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220125095854077.png)

key를 지정해주면 원하는대로 정렬가능



**sorted 함수 -----> 정렬된 새로운 리스트를 반환, 원본변경 x**



<튜플>

a = (1, 2, 3)

a += 1,

라고 해주면 (1, 2, 3, 1)이라는 새로운 id의 튜플이 생김



list는 변경가능하므로 1추가해줘도 같은 id 임



a == b   값을 비교

a is b    주소 값을 비교     -----> 사용할일 거의없음







<셋>

중복제거해서 서로다른 원소 개수를 알기 위해 사용

여기선 append가 아닌 add 



<딕셔너리>

d.get(k)      

d.keys()

[' ']

딕셔너리에서 값을 꺼내올 수 있는지....가 중요



#### 얕은 복사와 깊은복사

같은 주소인지는 id로 확인해보면됨

얕은 복사는 같은 메모리 주소를 가리키게 하는 복사!!

c_list = o_list

슬라이싱을 하면 새로운 리스트를 내놓는다





깊은 복사는 메모리를 새롭게 할당

c_list와 o_list는 별개가됨

copy.deepcopy(오리지널 리스트명)



맨처음에 문제에서 주는 리스트

조작하다가 원래있는 리스트에 접근하고 싶을 때 딥카피 사용(원본 데이터 보존)

딥카피의 단점 : 메모리를 많이 사용(space limit 때문에 에러날수도)

time / space









