# OOP 기초



속성은 변수,  메소드는 클래스 안에 정의된 함수

객체를 비교할 때 비교연산자는 구현 후에 사용가능하다

클래스변수는 공통으로 적용되고 인스턴스 변수는 개별 적용됨

인스턴스로 부터 인스턴스 변수를 만들어낼 수가 있다(클래스변수를 마음대로 바꿔버리면 안됨)

Person.cnt += 1이라고 해줘야 하나씩 증가시킬수 있음

![image-20220127091944486](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220127091944486.png)

인스턴스를 만들면 네임 스페이스가 생김

클래스 네임 스페이스보다 인스턴스 네임 스페이스를 먼저 읽음

---->> 인스턴스와 클래스의 네임이 겹치면 안되는 이유

--

매직메소드

_ _ str _ _ : 인스턴스를 문자열로 바꾸면 어떻게 바꿀건지

_ _ len(self)_ _ : 클래스의 길이라는 개념을 만들어줌

__ equal(self, other) _ _ : 무엇으로 같다는 것을 비교할건가

--

메서드 정의시 첫번째 파라미터로 self를 적어주지 않으면 오류가 남

self -- 인스턴스 자기자신

self의 이름을 바꾸면 안됨(암묵적인 규칙)



<인스턴스 메소드   //    클래스 메소드>

메소드는 함수!

특별히 뭔가가 아니면 다 인스턴스 메소드

클래스 안에 정의된 함수가 인스턴스 메소드(self로 아무것도 안하면 스태틱 메소드가 됨)

----------------------------------------------------------

<클래스 메소드> 

from --- import ~~

~~.() 해주면 되고

import ~~하면

--.~~.() 해줘야함( 모듈에서 한번 부르고 함수 )



@는 데코레이터(함수를 어떤 함수로 꾸며서 새로운 기능을 부여)

함수가 여러개, 각각 함수를 반복해야할 일이 많을 때 사용

![image-20220127093938854](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220127093938854.png)

------------------>  이 구조를 외우면됨!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

![image-20220127094107571](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220127094107571.png)

@ 하나만 써주면 위에 정의된 함수대로 값이 출력됨

![image-20220127094254347](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220127094254347.png)

---------> 뒤에 ()은 실행하라는 뜻 (test_a까지는 decorated함수 반환하는것)

``` python
def time_display_decorator(origin_func):
    def decorated():
        print(dt.now())
        origin_func()
        print('----')
    return decorated       # 여기서 decorated는 wrapper도 가능

@time_display_decorator
def test_a():
    print('test_a')

@time_display_decorator
def test_b():
    print('test_b')

test_a() # time_display_decorator(test_a)()
         # time_display_decorator()
test_b()
```



데코레이터는 **일급객체**와 연결되어 있음(심화)

![image-20220127095239774](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220127095239774.png)

![image-20220127095258271](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220127095258271.png)

----------------> 읽을 때 필요할 수도...(몰라도 크게 상관은없음)

스네이크 케이스 ->함수로 정의된 데코레이터

파스칼 케이스 -> 클래스로 정의된 데코레이더(위에는 파스칼 케이스)





-------------------------

클래스 메소드

@classmethod 데코레이터를 사용하여 정의!

호출 시 첫번째 인자로 클래스(cls)가 전달됨

인스턴스 만들지 않아도 호출가능함

클래스 변수 조작시에 클래스 메소드 사용!

``` python
class MyClass:

@classmethod
```



-----------

스태틱메소드

인스턴스변수나 클래스변수를 가지고 어떤 역할도 하지않지만 클래스 안에 어떠한 역할을 하는 메소드

클래스. 하고 호출가능(인스턴스를 만들 필요가 없기 때문)

안써도 동작은 되지만 클래스와 인스턴스 둘과는 관계가 없다는 것을 알려주기 위해 @staticmethod

변수를 다루지 않고 단지 기능만을 하는 메소드를 정의할때 사용!!!!

호출시 어떠한 인자도 전달되지 않음(클래스 정보에 접근/수정불가)

--------------------------



#### 객체 지향의 핵심개념

핵심 4가지 ------------**시험!!!**

추상화 / 상속 / 다형성 / 캡슐화

* 추상화

현실 세계를 프로그램 설계에 반영(고수준 -> 저수준)



* 상속

두 클래스 사이 부모- 자식 관계를 정립

class A:

class A():

class A(object):      -> object를 상속받은 A라는 클래스를 정의한다는 뜻



3개는 같은말이다 가장 위에것이 최신버전

object를 안써도 되지만 숨어있는것

모든 파이썬 클래스는 object를 (자동으로) 상속받음

------> 알려주는 이유는 예전버전과의 호환성 때문에 사용하는 사람들이 있기 때문



하위클래스는 상위클래스의 모든것을 상속 받음,   **코드 재사용성이 높아짐**

실제 개발에서는 작은 단위로 클래스를 나누어서 계층 구조를 다양하게 만듬 -----> 재사용성

DRY   코드를 단 한줄도 반복하지마라는 뜻(파이썬에선 중요)

지금 현재에선 푸는 것이 가장 중요함(로직 - 알고리즘)



isinstance(object, classinfo)   object가 classinfo로 만들어졌니?

classinfo의 instance거나 subclass*인 경우 True

is ~~~ ---> T/F로 return되는 경우



super() 

부모클래스의 무언가를 사용하고 싶은경우(직접 접근하고 싶을때)

![image-20220127110325414](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220127110325414.png)

name, age, number, email을 받아서 사용하겠다



메소드 오버라이딩 - 자식클래스에서 부모클래스와 같은 이름의 함수를 정의하면 부모클래스의 것은 무시됨(자식이기는 부모없다)

부모클래스의 것을 한번 덮어써서 사용하는 것

![image-20220127110652087](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220127110652087.png)



**다중상속**

두개 이상의 클래스 상속받음

상속받은 모든 클래스 요소를 활용 가능

상속 순서에 의해 결정됨

(A, B, C) -> A B C 순서대로

![image-20220127111157064](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220127111157064.png)

메소드 오버라이딩에 의해 자식이 부모를 이김

mom, dad도 cry가 있더라도 baby만 cry 나옴

같은 이름의 메소드이면 자식의 것만 !

baby1 = FirstChild('아가')- ----> 아가는 dad mom 클래스에도 없으니까 person클래스로감





mro메소드(method resolution order)

![image-20220127111515611](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220127111515611.png)

어떤 순서대로 받았는지 알 수 있음



---------

* 다형성(Polymorphism)

어느 수준을 넘어가면 영어로 봐야함

유튜브 강의?  -- 키워드로 캐치하면 이해할 수 있음

--

동일한 메소드가 클래스에 따라 다르게 행동할 수 있음

서로 다른 클래스에 속해있는 객체들이 동일한 메시지에 대해 다른 방식으로 응답될 수 있음

하나의 클래스에 여러 타입의 객체가 올 수 있음

하나의 클래스가 여러 객체로 받고 여러 응답을 할 수 있다(같은 메소드로)

--

메소드 오버라이딩

부모클래스에서 정의한 메소드를 자식클래스에서 변경

-------

* 캡슐화

1.비슷한 기능을 하는 속성과 메서드를 묶는 작업

2.은닉성-> 접근에 대한 권한

객체의 일부 구현 내용에 대해 직접적인 엑세스 차단

--

<심화>

응집도(cohesion), 결합도(coupling)(의존성)

비슷한 기능을 하는 메서드가 얼마나 뭉쳐져있는가

각각의 속성과 메소드가 얼마나 서로에게 의존되어있는가

-응집도는 높을수록, 결합도는 낮을수록 좋은것!

--

접근제어자 종류

public          다 가능

  언더바 없이 시작하는 메소드나 속성

  어디서나 호출가능(클래스 밖에서도 당연히), 오버라이드 o

  일반적으로 작성되는 메소드와 속성의 대다수

protected     나랑, 내 자식 (안에서)만 가능       클래스.~~ 이거안됨

  **언더바 1개**로 시작하는 메소드나 속성

  부모클래스 내부와 자식클래스에서만 호출가능

  -->밖에서 접근해도 오류는 안나지만 암묵적인 규칙이기 때문에 지켜야함

  하위 클래스 오버라이드 가능

private         나만 가능          내 클래스 안에서만 접근가능(자식도 안됨)

  본 클래스 정의부  그 안에서만 할 수 있음

  **언더바2개**로 시작하는 메소드나 속성

  하위클래스 상속 및 호출 불가능(오류)

  외부 호출 불가능(오류)



은닉성을 하려면 private 보다는 protected를 쓰는 것을 권장

<심화>

![image-20220127125727542](OOP%20%20%EB%B3%B5%EC%8A%B5.assets/image-20220127125727542.png)

직접 접근하지말고 메서드를 통해서 접근해야함

![image-20220127125908171](OOP%20%20%EB%B3%B5%EC%8A%B5.assets/image-20220127125908171.png)

밖에서 맘대로 가져가지 못하고 무조건 메서드를 사용해라!!(이게 접근제한자 사용법)



<심화>

dir()해서 보면 안에 속성과 메서드 확인가능

name mangling

_class이름__ 

파이썬은 이러한 방법으로 private에 접근을 막는다

dir 안에 있는 걸로 돌리면 가능하지만 꺼내쓰면 안됨!!

--



getter 메소드와 setter 메소드

무언가를 주면 getter (갖고있는 속성을 줌)

getter 메소드 -----> @property

무언가를 설정하면 setter (새로운 값 받아서 할당)

setter 메소드 ------> @변수.setter

귀찮아서 쉽게 사용하려고 쓰는 것!

![image-20220127131937019](OOP%20%20%EB%B3%B5%EC%8A%B5.assets/image-20220127131937019.png)

![image-20220127132042948](OOP%20%20%EB%B3%B5%EC%8A%B5.assets/image-20220127132042948.png)

메서드인데 속성처럼 사용가능

<심화>

@name. 하면 밑으로 getter가 뜨는데 @property와 같은것

이건 상속받아서 게터를 따로 오버라이드 해줘야할때 사용

--

