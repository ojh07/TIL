서버는 웹 서버와 API 서버로 나뉜다

리퀘스트가 왔을 때 **웹페이지**를 리스폰스의 바디에 담아서 주는것이 웹 서버(화면을 그리는데에 필요한 것들)

리퀘스트가 왔을 때 **요청한 것에 대한 처리를 하고 그 결과**를 리스폰스의 바디에 담아서 JSON형식으로 주는 서버가 API 서버

두개를 같이 쓸수도 있지만 현업에서는 나눠서 쓰는것이 일반적

이때까지는 Django를 웹서버로 사용했지만 이제는 API서버로 사용해보자는 것



HTTP -> 클라이언트와 서버가 서로 어떤 형식으로 데이터를 보내줄건지 약속한 것(규약)

클라이언트와 서버가 서로 데이터를 주고 받으려면 '프로토콜'이 필요하다. 웹 개발에서는 HTTP, HTTPS가 중요!

FTP, SSH, TELNET, SMTP, HTTP, HTTPS(secure-조금더안전?)....모두다 프로토콜의 종류



## HTTP의 기본 특성

* 비연결성(Connectless) - 클라이언트와 서버가 한번 응답을 주고 받으면 연결을 끊는다
* 무상태(stateless) - 비연결성 때문에 발생한 것, 서버가 클라이언트를 기억하지 못함(식별 불가능), 내가 누군지를 서버에게 알려줘야한다.

=> 쿠키와 세션 등장!

쿠키 - 클라이언트 너가 기억해서 나(서버)한테 들고와

=> 문제 : 쿠키가 굉장히 쉽게 뺏긴다(보안이 취약)  => 세션이 등장

세션 - 그 민감한 정보, 서버가 기억해 줄게(쿠키에는 세션의 id만 담아줌)



### HTTP Method

GET - 조회

POST - 생성

PUT - 수정

DELETE - 삭제

이것을 보고 서버가 어떤 행동을 하려는지 결정

HTTP Method는 request에 담겨있다.(클라이언트 -> 서버) 

request는 Head와 Body로 나뉘어져있다

Head에는 요청에 대한 부가정보(HTTP Method) - 항상 정보가 들어가있음

Body에는 실제 데이터(요청에 따라 있을수도 없을수도 있음 - GET, DELETE는 BODY가 필요없다)

Header => 리퀘스트, 리스폰스 헤드안에 담겨있는 각각의 정보들을 헤더라고 한다(method, path, scheme, cookie....) 

헤더안에 있는 user_agent는 소중한 데이터 종류가 된다



HTTP Response도 Head와 Body로 나뉜다

Head안에 status code라는 중요한 요소가 있다

각각의 상태코드는 숫자에 불과하지만 그 안에는 상태메시지가 있다

5개의 그룹으로 나뉘어져있다

100번대 - 서버가 클라이언트한테 정보성 응답을 줌

* 100 - Continue(클라이언트가 서버에게 요청했을 때 100해주면 계속해도된다는 뜻으로 주는 상태코드)

**200번대** - 일반적인, 정상적인 상황

* 200 - OK(잘 처리됨!)
* 201 - Created(데이터가 잘 생성되었다)

300번대 - 클라이언트가 서버에 요청했을 때 뭔가 추가적으로 더 필요하다는 것을 뜻함

* 301 - Moved Permanently - 요청한 리소스가 그 위치가 아니라 다른 곳으로 이동되었어(이 메세지 주고redirect를 한다)
* 304 - Not Modified - 수정되지 않음(이미지와 같은 리소스를 한번 서버에서 받았을 때 가지고 있다가 다시 그 페이지를 방문할 때 => 네트워크 자원이 절약됨 => 브라우저 캐싱과 연결됨)

**400번대** - 클라이언트가 잘못했어

* 400 - Bad Request (요청은 제대로했는데 형식이나 문법이 잘못됨, 오타내는것도 포함)
* 401 - Unauthorized(인증과 관련, 요청은 잘했는데 인증부터 해야합니다!라는 뜻)
* 403 - Forbidden(권한과 관련, 인증을 했는데 권한에서 막힌것)
* 404 - Not Found(없는 리소스를 요청한 것)
* 429 - Too Many Request(너무 많은 요청이 들어왔다)

**500번대** - 서버가 잘못했어

* 500 - Internal Server Error(클라이언트 요청은 올바르지만 서버 내부에서 오류가 생겨서 처리불가)
* 503 - Service Unavailable(수강신청, 티케팅 등 갑자기 너무 많은 요청이 한번에 서버에 들어와서 일시적으로 서비스 제공이 불가한 경우, 또는 서버가 점검중인 경우)

여기서 200, 400, 500번대가 중요!



resource => 서버에 존재하는 정보, 자원, 데이터

URI는 URL과 URN으로 나뉜다

URN은 우리가 사용하지 않기 때문에 URI를 URL이라고 보면됨

URL은 네트워크에서 요청한 리소스가 어디에있는지 표현한것(각 리소스의 위치를 나타냄)



### URI의 구조

Scheme(프로토콜)

=> 어떤 프로토콜을 쓰는지를 표현

Host(도메인 이름)

=> 요청받는 웹서버의 이름

Port 

=> 리소스에 접근하는데 사용되는 문(HTTP 80, HTTPS443이 많이쓰인다)

Path

=> 어떻게 URL이 나뉘어지고 있는지(리소스의 경로)

Query

=> &으로 구분되는 key-value목록

Fragment

=> #뒤의부분, 서버로 전송되지 않음(정보를 조금더 쉽게 접근하기 위해 붙이는 부분)



## API

Web API - 프론트엔드가 어떤 URL로 어떤 구조를 리퀘스트를 보내면 어떤 리스폰스를 내려줄게를 약속한 규칙

약속이기 때문에 어떻게 설계해도 기능적으로 문제가 없다. 하지만 지켰을 때 얻을 것이 훨씬 많다!

REST API - 거의 대부분의 웹 개발자들이 웹 API를 설계할 때 지키기 위한 가이드라인 중 하나

REST API를 따르는 서비스가 RESTful 서비스(요즘의 거의 대부분의 서비스!)

API설계시 따라야할 2가지

1. URL은 리소스를 나타내기 위해서만 사용하고, 리소스에 대한 처리(행위)는 메서드로 표현한다.
2. Document는 단수명사로, Collection(Document가 모인것)은 복수명사로 표현한다.



PUT은 POST랑 같지만 serializer = ArticleSeril~(**article**, data=request.data) 여기서 article만 추가된것

PATCH는 부분적으로 바꿀 때 사용

부분적으로도 PUT사용해서도 가능 => partial=True추가해주면됨!!





![image-20220421162828124](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220421162828124.png)

파란색 박스부분만 해주면 됨!



![image-20220421164551993](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220421164551993.png)

밑에 get방식이 새로운 내용

article_pk번 article에 달린 댓글들 다 보여줌

filter 사용!!(article=article)

여러개니까 many=True 필요!

댓글개수구하기같은거는 평가에 안나옴

