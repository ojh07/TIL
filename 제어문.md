인터프리터언어 vs 컴파일 언어(기계 바뀌면 소스코드 다시빌딩해야함)

자바는 둘다 해당됨



OOP 객체지향 프로그래밍

절차지향 / 객체지향 / 함수형

모든 프로그래밍은 절차를 지향함

객체지향 - 데이터 + 함수      프로그래밍 크기가 커지면서 객체라는 것을 설계하기 어려워짐

-> 함수형 등장(최소유닛으로 동작하는 함수만 만들어서 프로그래밍)



python ~~.py   -> 파이썬 전체코드 실행됨

vs code 에 익스텐션을 설치하면 여러기능이 추가됨! -> 파이참과 비슷해짐

파이참은 파이썬에 특화된 IDE(통합개발환경) - **알고리즘** 디버깅 시 더 자세한 정보를 보여줌

웹이나 장고 등도 VS CODE 이용함

주피터노트북은 읽으면서 복습하기 좋음!

대부분은 VS CODE 활용!!!!



따옴표 혼용하지 않기, 들여쓰기 우선 이것만 주의!!!

lint라는 도구 - 소스코드를 분석해서 스타일가이드에 맞지 않는 부분에는 빨간표시를 해주고 어떤게 잘못되었는지 알려줌

python은 pylint라고 함(레벨을 낮출 수 있음)  ,    black이라는 패키지는 아예 고쳐주기도함

**우선 코드를 잘 짜는게 중요!!!**



메모리는 RAM   (각각이 셀로구분됨 각각 주소값으로 래핑되어있음)



주석은 매우중요!! 습관들이기(가능하면 영어로- 먼저 한글로 다는 습관 기르기)

주석으로 대략적으로 경로를 그리면서 가면 더 빠름(알고리즘때 생각이 길고 코딩은 짧아야함)

따옴표 3개(여러줄)나 #(한줄)으로 표현하면됨



빈문자열, 빈배열은 FALSE이다  라는 것을 자주 사용함!(IF문과 함께)

부동소수점 - 알고리즘때 실수를 컴퓨터가 저장하는 방법

문자열은 불변, 반복가능



이스케이프 시퀀스 - \를 활용하여 여러가지가 있음

\r 은 커서가 맨앞으로감(abcde\rfg -> fgabcde로 출력)



string interpolation 

문자열 쓰기전에 f만 써주면 됨   변수자체를 중괄호로 넣어줄 수가 있음

f - strings 매우 자주쓰고 가장 편리함!!

%- formatting과 str.format()도 해석할 수 있어야하기 때문에 이해할 수 있어야함!



None - 파이썬 자료형 중 하나(값이 없음을 표현)



컨테이너 - 서로 다른 자료형을 저장할 수 있게함

![image-20220118102429773](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220118102429773.png)



리스트 - 순서를 가짐,   **0부터 세는 것** 매우 중요!!!! ,  대괄호 사용 또는 list()

코드작성시 가독성이 매우중요!, 한줄로 쓰려고 노력할 필요없음

인덱스는 번호! (처음것 0 또는 **맨끝에것을 -1**로 쓸 수 있음!)



튜플 - 리스트와 비슷하지만 불변

소괄호{}또는 tuple()로 생성 

일반적으로 파이썬 내부에서 활용됨. 자주 사용하지 않음



레인지 - 리스트와 함께 자주사용 

숫자의 시퀀스를 나타냄 (기본, 범위지정, 범위+스텝 지정)



패킹/언패킹

전체패킹은 튜플, 부분패킹은 리스트, 언패킹은 리스트로 

x = 1, 2, 3 이라고하면 x가 튜플로 묶임  {1, 2, 3}

x, y = 1, 2, 3, 4 이라고 하면 오류

x, *y = 1, 2, 3, 4라고 하면 x에는 1, y에는 나머지것들이 담김 [2, 3, 4]  

부분패킹이라 리스트로 들어감

a = 1, 2, 3, 4, 5 라고 하면 튜플 {1, 2, 3, 4, 5}

언패킹

x, *y = a라고 하면 x에는 1, y에는 [2, 3, 4, 5]  타입은 리스트

a는 전체패킹된것



셋 - 중복 값을 없애준다는게 가장 큰 기능!(len은 길이인데 서로다른 원소 개수라고 보면됨)

순서없이 0개 이상의 해시가능한 객체를 참조하는 자료형

중복이 있으면 해시불가능

집합과 동일한 구조여서 집합 연산이 가능

순서가 무시되므로 순서가 중요한 경우에는 사용불가!

셋으로 하고 리스트로 하면 순서도 정리됨!



딕셔너리 - 키와 값의 쌍으로 이뤄진 객체를 참조하는 자료형

이름표가 키, 박스 안에 것이 값

{} 중괄호 또는 dict()를 통해 생성

값은 모든 자료형 가능

키는 변경 불가능한 데이터만 활용가능, 중복되면 안됨





* 형변환

자료형 변환 - 암시적/ 명시적

암시적은 편하지만 위험할 수 있음(의도하지 않고 변환되기 때문)

true 가 1, false가 0

bool형은 정수형의 sub클래스로 정의됨



논리연산자

and는 모두 true여야 true

or은 하나라도 true이면 true



복합연산자 - 연산과 대입이 함께!

cnt = cnt + 1

cnt += 1   이 2개가 같은 것!!(더하기, 빼기, 곱하기 나누기 다가능)



멤버십 연산자

in과 not in   들어있다, 들어있지 않다를 체크하고 bool형(T/F)으로 반환해줌



시퀀스형 연산자

시퀀스간의 연결(+), 반복(*) 

리스트, 튜플, 문자열끼리는 더해도 레인지는 불가능!!



인덱싱 - 시작은 0 , 끝에서부터한다면 끝에것이 -1 인거만 명심

[A : B] - A는 포함 B-1까지



문자열 슬라이싱 한번 해보면 이해됨!



set 연산자

|, &, -, ^   이러한 것들은 알고리즘에서 더 많이 쓰임



연산자 우선순위

기준을 보고 하나씩보면 충분히 해석가능



함수는 def로 정의!

.py가 하나의 모듈

.py가 묶인것이 패키지

패키지가 묶인 것이 라이브러리



# 제어문

조건문/ 반복문                   흐름을 제어한다

* 조건문

if / elif / else

if안에 if문을 또 넣을 수 있음

조건표현식 



* 반복문

while / for

while문 - 조건식 참인경우 반복 실행

input은 무조건 문자열로 받기 때문에 정수 등으로 변환해줘야함

for문 - 언제까지 반복할지가 정해져있음

하나씩 꺼내서 출력



range(len()) 이 형태 매우 자주사용!!!

다 줄바꿈되어있는 것은 끝에 \n이 숨어있는 것!

print문은 자동 줄바꿈해줌

원래 print(    , end='\n')인데 end = ' '라고 해주면 가로로 하나씩 띄워서 써줌



딕셔너리 순회 ---->>> 매우 중요

keys(), values(), items() 



enumerate 순회 

인덱스번호를 같이 받고 싶을 때 



List Comprehension(리스트 압축) - 코드 줄이기

<expression> for 변수 in <iterable>

여기까진 익숙해지면 매우편리함!

iterable은 반복가능



딕셔너리도 comprehension 가능





*반복문제어*

break

continue

2개만 잘쓰면 됨!

pass는 무슨 내용을 넣어야할지 모르는데 에러는 나기 싫을때 사용 

else는 break같은거 안만나고 끝까지 실행한 이후에 실행됨





workshop 풀이



1.input() - 문자열로 입력받음

int(input()) - > 형변환

number = int(input())

for i in range(1, number + 1):

​	print(i)



2.for i in range(n, -1, -1)

​	print(i)

while true 하면 무한 루프(break로 멈춰줘야함)

print 중복될때는 밖으로 빼줘서 한번만 쓰면됨!]

반복횟수 정해져있을땐 for문이 편함



3.

number = int(input())

sum = 0

for i in range(number + 1)

​	sum += i

print(sum)



조건 :    time -> 실행

​           space -> 용량



homework 풀이

1.

import keyword

print(keyword.kwlist)

2.

import math

num1 = 0.1 * 3

num2 = 0.3

print(math.isclose(num1, num2))

3.

4.

5.

빈문자열이 아니면 true가 됨

6.

n = 5

m = 9

rec = (("*" * 5) + '\n') * m

pritn(rec)

문자열에 곱하기 연산, \n으로 줄바꿈 사용 

7.

