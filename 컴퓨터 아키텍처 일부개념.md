## sw 문제 해결 역량

핵심 : 많은 제약 조건과 요구사항을 이해하고 **최선의 방법을 찾아내는 능력**



## 복잡도 분석

알고리즘 : 문제를 해결하기 위한 절차나 방법

빅오 - 점근적 상한

빅오메가 - 점근적 하한(최소한 이만한 시간은 걸린다)

빅세타(빅오와 벡오메가가 같은 경우에 사용 - f(n)은 n이 증가함에 따라 n^2과 동일한 증가율을 가진다는 의미)



O(1) - 몇개가 들어오든 일정할 때 

O(n^3)까지는 어떻게든 잘 돌아가지만 O(2^n)지수시간부터는 조금 무리가 될수도 있다

알고리즘 코딩테스트에서는 O(n^2)을 넘지않도록 주의해야한다



## 표준 입출력 방법

raw값의 입력 : input() -> 받은 데이터를 문자열로 취급

출력 : print() -> 출력값 마지막에 개행문자 포함

개행문자 제외하고 출력하려면 print('text', end=' ')라고 해줘야함

input.txt파일의 크기가 1MB가 넘어가면 sys.stdin = open("input.txt", "r") 로 케이스를 입력받아야한다



## 비트연산

AND : &

OR : |           

XOR : ^        특정비트가 같은지 검사

반전시킴 : ~  

피연산자의 비트 열을 왼쪽으로 이동시킴 : <<

피연산자의 피트 열을 오른쪽으로 이동시킴 : >>

* 1<<n

2^n의 값을 가지며 원소가 n개일 경우 모든 부분집합의 수를 의미함

* i & (1 << j)

계산결과 : i의 j번째 비트가 1인지 아닌지를 의미함

* 엔디안

컴퓨터 메모리 등의 1차원 공간에 여러개의 연속된 대상을 배열하는 방법, HW 아키텍처마다 다름

빅 엔디안(큰단위가 앞에나옴 - 네트워크)과 리틀 엔디안(작은단위가 앞에나옴 - 데스크탑) 으로 나뉜다



## 진수

2진수, 8진수, 10진수, 16진수

10진수를 타진수로 변환 : 원하는 타진법의 수로 나눈뒤 나머지를 거꾸로 읽는다

2진수, 8진수, 16진수간 변환 => 2진수를 3자리씩 묶으면 8진수, 8진수를 3자리씩 나열하면 2진수

2진수를 4자리씩 묶으면 16진수, 16진수를 4자리씩 나열하면 2진수

사실 8진수는 자주 사용하지 않음

* 컴퓨터에서 음의 정수 표현

1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환

2의 보수 : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다



## 실수

컴퓨터는 실수 표현을 위해 부동소수점 표기법 사용

부동소수점 표기법 : 소수점의 위치를 고정시켜서 표현하는 방식(소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현)

실수를 저장하기 위한 형식 

* 단정도 실수(32비트)
* 배정도 실수(64비트)
  * 가수부 : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현
  * 지수부 : 실제 소수점의 위치를 지수 승으로 표현한 것

컴퓨터는 실수를 근사적으로 표현

32비트 실수형 유효자릿수(십진수) -> 6

64비트 실수형 유효자릿수(십진수) -> 15