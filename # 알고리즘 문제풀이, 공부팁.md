# 알고리즘 문제풀이, 공부팁



루프를 사용한 풀이(인간처럼 생각하면 안된다)

변수 초기화 위치, 범위설정, 예외처리와 같은 실수 --> 조심

테스트케이스에서 반례에도 적합하게 문제를 잘 이해하고 꼼꼼하게..!

문제를 이해하기 어렵다면 여러번 계속 읽어봐야한다(집중)

구현 -> 아이디어 구현(규칙성) -> 알고리즘, 자료구조

아이디어를 체계화시킨것이 알고리즘이다(뒤로갈수록 알고리즘+알고리즘, 알고리즘+아이디어)

템플릿을 정확히 익히고 그것에 따라 연습하자(동작원리 이해)



종이에 그려보고 적어보기 -> 실수도 줄이고 아이디어를 낼 수 있고 디버깅도 떠오른다

아이디어는 시각적으로 직관적으로 // 구현은 2차원 배열, 다중루프(for), 조건문

대략짜놓고 찍어보면서 디버깅하는것이 가장 좋지 않은 조합, 디버깅에 의존하면 좋지않다

외우려고 하지말고 이해하려고 해야한다

눈코딩하고 디버깅해야한다



문제풀이는 많이풀어볼수록 답이다

![image-20220218092855390](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220218092855390.png)

문제읽기는 속독으로 빠르게 읽어나가기(흐름파악) - 제약조건이나 중요하다고 생각되는건 체크하면서

TC 손으로풀기(주어지는 테스트케이스를 손으로 풀어봐야한다) , 부분정답일때는 문제 꼼꼼히 다시읽기

(시간을 정해놓고 푸는것도 어느정도 수준이 되면 도움이 된다)



접근방법 구상은 당연히 가장 중요함 // 사람의 방법이 아니라 배열, 반복문, 조건문으로 접근해야한다

아이디어를 여러개 적어놓으면 디버깅 힌트를 얻을수도 있다



핵심코드 손코딩은 시각적으로 그려가야한다(특히 arr, 범위, 반복문) 변수같은거 다 실명으로 명확히



코드구현은 오타없이 손코딩한것을 타이핑



디버깅 및 개선 - 코드구현이 틀린경우에는 디버깅(앞에 과정이 제대로 되지 않으면 브레이크포인트가 헷갈릴것이다), 너무안되면 다른사람코드 참조



핵심코드 손코딩까지의 과정이 가장 핵심이다



<접근방법 구상>

![image-20220218094413007](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220218094413007.png)

많은 문제를 풀면 유사문제시에 해법이 떠오를 수 있어서 유리하다

문제를 쪼갤 수 있는 능력(탑다운), 단계로 나누기

목적지가 있을 때 그 목적지에서 거꾸로 찾아오는 방법 같은 아이디어



<문제풀이 연습>

![image-20220218100527013](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220218100527013.png)

효율은 나중에.. 일단 정확하게 짜는 연습을 하자

디버거 사용법 숙지도 필요하다(안쓰는게 더 좋지만 써야할 때도 많다)

너무 급해도 몇분 시도후에도 안될 경우는 침착하게 코드를 다 지우고 새로하는게 더 좋을 수도 있다

문제를 한번말고 여러번 읽어보자(단, 반드시 같은거 주의깊게)

문제가 생기면 코드말고 손코딩 한것을 다시봐야한다

consolas 폰트 추천@



이름 여러개 익숙한거 정해놓기(갯수세는건 cnt, 최종결과는 rlt 등등..)

인덱스를 그대로 사용해주는게 좋다(추가하더라도) --- 인덱스와 일치시키자

단축키 아는건 적극적으로 활용

한줄씩 실행하고 값을 변경하는 것을 보는게 아니라 어떤 값을 예상하고 정말 맞는지 확인하는 과정을 디버깅을 통해서...

그림이 있는문제는 글먼저 엄청 자세히 읽기보다는 거꾸로 그림을 먼저보는것이 낫다

루프를 진행하면서 마무리짓고 다시 진행하면서 마무리 (이런식이 이중으로진행되는것보단 좋다)



응용으로가면 복잡도도 많이 신경써야하고 반대방향 등 다른 접근도 생각해봐야한다(효율)



파리퇴치 문제 기반 문제들 매우 많음(확실히 익히기!!)

x,y든 r,c이든 통일해서 사용하기 (그냥 r,c로 통일하기 )

2차원배열은 범위 특히나 더 신경써줘야한다

배열은 i,j 로 무조건 접근해야한다 for i for j 순서가 아니라 for j for i 순서로 받으면됨

문자열에서 빈자리인지 확인하려면 길이로 판단하면됨

''.join(리스트) 해주면 리스트가 공백없는 문자열로 바뀌어서 나옴!!

한겹을 임의로 더 추가해서 인덱스 관리할 수도 있어야한다--> 끝에서 별도로 범위체크 할필요 없어짐



알고리즘은 반드시 탑다운으로 짜야함

함수를 먼저짜는것이 아니라 메인이 되는 공간을 먼저 짜놓고 함수를 정의하러가야한다

i, j만 바꾸면 행, 열바꿀 수 있다(정치행렬 , zip 함수 이용)

유사한게 반복된다고 보이면 함수를 정의해야한다(너무길어지면 가독성이 안좋기 때문)



리스트를 만들어서 그 리스트의 요소를 lst[i]로 해서 빼서 사용할 수 있다

count배열 사용해서 중복확인 또는 개수세기



숫자배열 회전도 자주나온다

90도 함수 하나 만들면 몇번더 돌려도 편하다..?

![image-20220218155149784](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220218155149784.png)

![image-20220218155923715](C:/Users/%EC%98%A4%EC%A2%85%ED%98%81/AppData/Roaming/Typora/typora-user-images/image-20220218155923715.png)



파리퇴치, 스도쿠 문제 꼭 풀수있어야한다

둘다 범위조정이 중요하다

2차원배열안에서 인덱스조작 할 수 있는지를 물어보는것!!

im시험, 과목평가 둘다 마찬가지

과목평가는 필기도 포함됨(코딩실기+필기)

자료구조(리스트, 스트링) 배운부분에서 출제될것



파리퇴치 풀이

```python
# 파리 퇴치
import sys
from pprint import pprint

sys.stdin = open("input.txt")

T = int(input())
for tc in range(1, T + 1):

    # 입력 받기
    N, M = map(int, input().split())
    flies = [list(map(int, input().split())) for _ in range(N)]

    max_kill = 0
    for r in range(N - M + 1):
        for c in range(N - M + 1):

            curr_kill = 0
            for i in range(M):
                for j in range(M):
                    curr_kill += flies[r + i][c + j]  # 파리 계산

            if max_kill < curr_kill:
                max_kill = curr_kill

    print(f"#{tc} {max_kill}")
```



![image-20220218174709093](%23%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4,%20%EA%B3%B5%EB%B6%80%ED%8C%81.assets/image-20220218174709093.png)





